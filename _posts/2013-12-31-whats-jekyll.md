---
layout: post
title: Первый проект на Arduino: делаем хипстерскую сигнализацию с модным интефейсом
---

Тачскрин, цветной экран, рок-н-ролл вместо сирены.




В этом семестре (на память – первый семестр 4-го курса)  нужно было сделать курсовую по схемотехнике. Нашему потоку очень повезло, потому что в этот раз помимо теоретических навыков (будем честны: для меня они закончились бы в лучшем случае знанием разметки шрифта ГОСТа и поиском аналогичных схем в интернете) нам разрешили реализовать свой проект «вживую». 
Во славу всем божествам Лавкрафта, я смогла преодолеть этот не совсем легкий период моей жизни и сделать работающую полнофункциональную (!) сигнализацию. В общем, отличный повод создать блог и написать статью о преодоленном пути. :з
1. С ЧЕГО НАЧАТЬ?
Если Вы хотите чего-то достичь, нужно составить план. Итак, сигнализация должна детектировать несанкционированное вторжение в охраняемую территорию  и сообщать нам об этом. Для этой нам понадобится:
1. датчик движения (https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D1%82%D1%87%D0%B8%D0%BA_%D0%B4%D0%B2%D0%B8%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F) 
2.  датчик открытых дверей (https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D1%80%D0%BA%D0%BE%D0%BD ). 
Если система зафиксировала объект, она должна оповестить об этом – добавляем 
3. бипер (https://en.wikipedia.org/wiki/Buzzer) . 
Состояние устройства и его управление будет отображаться на 
4. LCD-экране. 
Логика сигнализации реализована с помощью
5. микроконтроллера.
Отобразим словесное описание в структурной схеме (рис. 1):

Pис. 1: Структурная схема сигнализации

Со структурной схемой уже не  так страшно нырять в схемотехнические реалии! c:
По-хорошему следующим этапом должно стать составление функциональной и принципиальной схем,  а потом уже поиск подходящих элементов.  В моем отчете эти пункты идут в обратном направлении: вначале я купила устройства, представленные на отечественном рынке  (кстати, в прямом смысле «рынке»), а после составила схему (так делать не очень хорошо): 
1.  датчик движения SB412A-01-003

2. герконовый датчик ДМК-П2 (единственный элемент , произведенный в СССР, а не в Китае)

(примерно в таком же состоянии находится и мой)
3. бипер BMT-1212BX 

4. LCD-экран TFT Touch LCD модуль


5. Гвоздь программы - микроконтроллер Atmega328 с обвязкой на Arduino UNO R3


+ 10 резистора на 10 КОм (резисторы лишними не бывают), которые мы будем использовать в качестве подтягивающих резисторов  с устройствами с TTL-logic interface.
 (подробнее здесь: https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D1%82%D1%8F%D0%B3%D0%B8%D0%B2%D0%B0%D1%8E%D1%89%D0%B8%D0%B9_%D1%80%D0%B5%D0%B7%D0%B8%D1%81%D1%82%D0%BE%D1%80).
2 ПРИНЦИПИАЛЬНАЯ СХЕМА
Так, как нам сделать так, чтобы все это дело работало? Можно, например, так (рис. 2): 

Pис. 2: Принципиальная схема сигнализации
Так, для общего развития: соответствие пинам Атмеги к пинам Ардуины пожно посмотреть здесь: http://cdn2.shopium.ua/d/arduino/uploads/ARDUINO_V2.png 
Если Вы не прогуливали схемотехнику, то сможете с легкостью разобраться что к чему (и вознегодовать из-за некорректного оформления).
Некоторые нюансы схемы:
1 . Светодиод и бипер  “повешан” на один пин. Потому что… НЕТ СМЫСЛА ИСПОЛЬЗОВАТЬ ДВА ПИНА ИХ И ТАК МАЛО – ВСЕ ЗАНИМАЕТ ЭКРАН. Я серьезно.  Нехватка пинов – это отдельная проблема, которая одного моего одногруппника заставила отказаться от идеи использования экрана вообще. Так что если хотите использовать экран и Ардуину уно в своем проекте – приготовьтесь к жесткой организации своей системы и жестокой экономии пинов.
Возвращаясь к схеме: почему вместе со светодиодом должен быть резистор, очень хорошо описано здесь: https://electronics.stackexchange.com/questions/32990/do-i-really-need-resistors-when-controlling-leds-with-arduino
Вкратце - если включить без него, то есть шанс спалить микроконтроллер. 
2. Конденсатор нужен из-за дебаунсинга (привет, китайская техника! http://ithappens.me/story/13303 ). Это такой эффект, при котором нажатие на клавишу (в моем случает открытие-закрытие геркона) сопровождается маленькими микронажатиями, которые микроконтроллер успешно отработает. Конденсатор «сглаживает» неровности.
3. В качестве бонуса добавлен разрыв цепи, потому что это просто и быстро, а мне хотелось побыстрее посмотреть, как и что работает.
Ну от и все! Основная теоретическая часть закончена! Приступаем к сбору схемы.
3. СБОР СХЕМЫ

Сама интересная часть работы! 
Берем беспаечную плату, 
берем шнур штекер-штекер, 
подключаем элементы в соответствии со схемой
…
Профит :p
Хотя нет, постойте. Давайте подключим вначале без экранчика, потому что с ним отдельная история (см. далее). Вот что у меня получилось, например:


Рис. 3: Cигнализация с двумя датчиками движения, но без экрана (вокруг валяются куски проводов, потому что я купила шнур штекер-гнездо :c )
Можно, например, протестировать такой код:  если датчик движения сработал, то генерируется громкий сигнал, нет – тише.
void setup()  {
  Serial.begin(9600);
  pinMode(12, OUTPUT);
}

void loop()  {
     PIRstate = analogRead(0);
     if(PIRstate > 650){
      Serial.println(PIRstate);
     analogWrite(12, 40); // Almost any value can be used except 0 and 255
      delay(1000); // wait for a delayms ms
     }
     else{
      analogWrite(12, 2);
     delay(1000); // wait for a delayms ms
     }
    delay(1000);
}

4. ИСТОРИЯ С LCD ЭКРАНОМ


Вот она – заветная цветная отрисовка и тачскрин. Но почему ничего не работает?
А теперь приготовьтесь к самому интересному: c вероятностью в 59 процентов использование моего кода в стиле «скопировать-вставить» НЕ ПОЛУЧИТСЯ.
Дело в том, что TFT Touch LCD-экран любят производить китайцы, причем производить так, что чипы, от которых зависят библиотеки экрана, РАЗНЫЕ И НЕ СОВПАДАЮТ С ТЕМИ, ЧТО НАПИСАНЫ НА ЭТИКЕТКЕ, И ЧЕРТ ЗНАЕТ, ЧТО ДЕЛАТЬ. Энтузиасты, которые тоже столкнулись с тем, что официальные библиотеки не работают на их китайских покупках, переписывают для своего экран новый вариант библиотек и скидывают его на форум. Так что, если Вы такой же бедный родственник, как и я, купивший дешевый экран (зато цветной и с тачскрином), у вас есть два развития событий:
1. Переписать самому библиотеку – не очень катит, судя по тому, что Вы читаете мою статью
2. Гуглить разные библиотеки и перепрошивать  до тех пор, пока не заработает что-то. 
Мне нечего сказать, господа и дамы. Поучительная история того, что надо делать патчи в своих проектах…


5 ПИШЕМ КОД

Допустим, предыдущий челлендж Вы успешно прошли и единственное, что стоит между Вами и готовой сигнализацией – ее прошивка (ну и паяние на другую макетную плату, не важно).

Давайте разберем логику программы (рис. 4):


Рис. 4: Граф работы программы
В бесконечном цикле постоянно опрашиваются значения датчиков, и в зависимости от того, какие значения мы получаем, граф переходит в то или иное состояние. Изначально (опрделеляется константой) сигнализация активна. Пользователю дается некоторое время (задается константой – у меня это 30 секунд) на «собраться и уйти». После устанавливаем флаг, что сигнализация работает. Из этого состояния мы можем или отключить ее, или активировать, затронув датчики (вор!) срабатывает бипер и для его отключения надо ввести пароль (123456 – устанавливается прошивкой). Если вводится верный пароль – сигнализация отключается, неверный – продолжает громко сообщать о вторжении. 

Вот, собственно, и все:

switch(gFSMState){
    case FSMSTATE_RESET: 
      passed = gCurrentMillis-gTimeoutStart;
      if(passed>START_TIMEOUT){
        Serial.println("Starting");  
        gFSMState = FSMSTATE_ACTIVE;
        showState = true;
      }else{
        showState = timer;
      }
      break;
    case FSMSTATE_ACTIVE: //protection on
      sensors = readSensors(timer);
      if(sensors!=0){
        gSensors = sensors;
        gTimeoutStart = gCurrentMillis;
        gFSMState = FSMSTATE_DETECT;        
        showState = true;
      }
      break;
    case FSMSTATE_DETECT:     
      sensors = readSensors(timer); 
      passed = gCurrentMillis-gTimeoutStart;
      if(passed>DEACTIVATE_TIMEOUT){
        activateAlert();
        gFSMState = FSMSTATE_ALERT;
        showState = true;
      }else{        
        showState |= timer;
      }
      break;
    case FSMSTATE_ALERT:       
      sensors = readSensors(timer);   
      showState |= timer;
      break;
    case FSMSTATE_INACTIVE:            
      break;
    case FSMSTATE_WAIT:
      passed = gCurrentMillis-gTimeoutStart;
      if(passed>ACTIVATE_TIMEOUT){
        Serial.println("activateAlarm");  
        gFSMState = FSMSTATE_ACTIVE;
        showState = true;
      }else{
        showState |= timer;
      }
      break;     
    default:
      gFSMState = FSMSTATE_ACTIVE;
      showState = true;
      break;     
  }
  if(showState){
    dumpStateSerial();
    displayState(buttonsWereVisible, sensors);  
  }
  
  gCounter++; 
}

 А теперь бегом за кодом и паяльником! Мы надежно защищены! ( ͡° ͜ʖ ͡°)


[Jekyll](http://jekyllrb.com) is a static site generator, an open-source tool for creating simple yet powerful websites of all shapes and sizes. From [the project's readme](https://github.com/mojombo/jekyll/blob/master/README.markdown):

  > Jekyll is a simple, blog aware, static site generator. It takes a template directory [...] and spits out a complete, static website suitable for serving with Apache or your favorite web server. This is also the engine behind GitHub Pages, which you can use to host your project’s page or blog right here from GitHub.

It's an immensely useful tool and one we encourage you to use here with Lanyon.

Find out more by [visiting the project on GitHub](https://github.com/mojombo/jekyll).
