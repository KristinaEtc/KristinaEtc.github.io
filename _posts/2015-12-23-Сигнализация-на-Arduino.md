---
layout: post
title: Первый проект на Arduino: делаем хипстерскую сигнализацию с модным интефейсом
---

В этом семестре (на память – первый семестр 4-го курса)  нужно было сделать курсовую по схемотехнике. Нашему потоку очень повезло, потому что в помимо теоретических навыков (буду честной: для меня они закончились бы в лучшем случае знанием разметки шрифта ГОСТа и поиском аналогичных схем в интернете) нам разрешили реализовать свой проект «вживую». 
Во славу всем божествам Лавкрафта, я смогла преодолеть этот не совсем легкий период моей жизни и сделать работающую полнофункциональную (!) сигнализацию. В общем, отличный повод создать блог и написать статью о преодоленном пути. :з

### С ЧЕГО НАЧАТЬ?

Первым делом надо составить план. Итак, сигнализация должна детектировать несанкционированное вторжение в охраняемую территорию  и сообщать нам об этом. Для этой нам понадобится:

1. [датчик движения](https://ru.wikipedia.org/wiki/%D0%94%D0%B0%D1%82%D1%87%D0%B8%D0%BA_%D0%B4%D0%B2%D0%B8%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F);
2. [датчик открытия дверей](https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D1%80%D0%BA%D0%BE%D0%BD);
3. если система зафиксировала объект, она должна оповестить об этом – добавляем [бипер](https://en.wikipedia.org/wiki/Buzzer); 
4. cостояние устройства и его управление будет отображаться на [LCD-экране](http://wiki.amperka.ru/%D1%81%D1%85%D0%B5%D0%BC%D1%8B-%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F:%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0);
5. логика сигнализации реализуется с помощью [микроконтроллера](http://habrahabr.ru/search/?q=[%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D1%8B]&target_type=posts).

Отобразим словесное описание в структурной схеме (рис. 1):

![alt tag](https://raw.githubusercontent.com/KristinaEtc/KristinaEtc.github.io/master/schemes/1pr.png)
<em>Pис. 1: Структурная схема сигнализации<em>

По-хорошему следующим этапом должно стать составление функциональной и принципиальной схем,  а потом уже поиск подходящих элементов.  В моем отчете эти пункты идут в обратном направлении: вначале я купила устройства, представленные на отечественном рынке, а после - составила схему (так делать не очень хорошо): 

1. датчик движения SB412A-01-003
2. герконовый датчик ДМК-П2 
3. бипер BMT-1212BX 
4. TFT Touch LCD модуль
5. микроконтроллер Atmega328 с обвязкой на Arduino UNO R3
6. 10 резистора на 10 КОм (резисторы лишними не бывают). [Подтягивающие резисторы](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D1%82%D1%8F%D0%B3%D0%B8%D0%B2%D0%B0%D1%8E%D1%89%D0%B8%D0%B9_%D1%80%D0%B5%D0%B7%D0%B8%D1%81%D1%82%D0%BE%D1%80) нужны для устройств без TTL-logic interface.

### ПРИНЦИПИАЛЬНАЯ СХЕМА

Имея конкретные модели и технические характеристики элементов, можно составить принципиальную схему (рис.2):

![alt tag](https://raw.githubusercontent.com/KristinaEtc/KristinaEtc.github.io/master/schemes/2func.png)
<em>Pис. 2: Принципиальная схема сигнализации<em>

>Для общего развития: подключение пинов Atmega328 к пинам Arduino Uno R3 пожно посмотреть [здесь](http://cdn2.shopium.ua/d/arduino/uploads/ARDUINO_V2.png).

Если Вы не прогуливали схемотехнику, то сможете с легкостью разобраться что к чему (и вознегодовать из-за некорректного оформления).

Рассмотрим схему внимательнее:

1. Светодиод и бипер  “повешан” на один пин. Потому что… нет смысла использовать 2 пина, если можно занять 1. Я серьезно.  Нехватка пинов – это отдельная проблема, которая одного моего одногруппника заставила отказаться от идеи использования экрана вообще. Так что если хотите использовать экран и Arduino Uno в своем проекте – приготовьтесь к жесткой организации своей системы и жестокой экономии пинов.
Возвращаясь к схеме: почему вместе со светодиодом должен быть резистор, очень хорошо описано [здесь](https://electronics.stackexchange.com/questions/32990/do-i-really-need-resistors-when-controlling-leds-with-arduino).
Одним словом, если включить без него, то появляется шанс спалить микроконтроллер. 
2. Конденсатор нужен из-за [дебаунсинга](http://ithappens.me/story/13303) (привет, китайская техника!). Это такой эффект, при котором нажатие на клавишу - в моем случает открытие-закрытие геркона - сопровождается маленькими микронажатиями, которые микроконтроллер успешно отработает. Конденсатор «сглаживает» неровности.
3. В качестве бонуса добавлен разрыв цепи, потому что это просто и быстро, а мне хотелось побыстрее посмотреть, как и что работает.

Вот и все. Приступаем к сбору схемы.

### СБОР СХЕМЫ

Сама интересная часть: берем беспаечную плату, шнур штекер-штекер, подключаем элементы в соответствии со схемой,
…
профит.

Вот что получается без подключения LCD-экрана:

![alt tag](https://raw.githubusercontent.com/KristinaEtc/KristinaEtc.github.io/master/schemes/3photo.jpg)
<em>Рис. 3: Cигнализация с двумя датчиками движения, но без экрана (вокруг валяются куски проводов, потому что я купила шнур штекер-гнездо)<em>

Можно, например, протестировать тривиальный код:  если датчик движения сработал, то генерируется громкий сигнал, нет – тише.

{% highlight js %}
void setup()  {
  Serial.begin(9600);
  pinMode(12, OUTPUT);
}

void loop()  {
     PIRstate = analogRead(0);
     if(PIRstate > 650){
      Serial.println(PIRstate);
     analogWrite(12, 40); // almost any value can be used except 0 and 255
      delay(1000); // wait for a delayms ms
     }
     else{
      analogWrite(12, 2);
     delay(1000); // wait for a delayms ms
     }
    delay(1000);
}
{% endhighlight %}

### LCD-ЭКРАН

![alt tag](https://raw.githubusercontent.com/KristinaEtc/KristinaEtc.github.io/master/schemes/4lsd.jpg)

Заветная цветная отрисовка и тачскрин. Но почему ничего не работает?

А теперь приготовьтесь к самому интересному: c вероятностью в 59 процентов использование моего кода в стиле «скопировать-вставить» не получится.
Дело в том, что TFT Touch LCD-экран любят производить китайцы, причем производить так, что чипы, от которых зависят библиотеки экрана, в одной и той же модели экрана разные, и не совпадают с той моделью, которая обозначена в документации. Энтузиасты, которые тоже столкнулись с тем, что официальные библиотеки не работают на их китайских покупках, переписывают для своего экрана новый вариант библиотек и скидывают его на форум. Так что если Вы такой же бедный родственник, как и я, купивший дешевый экран (зато цветной и с тачскрином), у вас есть два способа работать с экраном:

1. Переписать самому библиотеку 
2. Гуглить разные библиотеки и перепрошивать  до тех пор, пока не заработает что-то. 

Мне нечего сказать, господа и дамы. Поучительная история того, что надо делать патчи в своих проектах.


### ПИШЕМ КОД

Допустим, предыдущий челлендж успешно пройден и единственное, что стоит между Вами и готовой сигнализацией – ее прошивка (и припойка на макетную плату).

Давайте разберем логику программы (рис. 4):

![alt tag](https://raw.githubusercontent.com/KristinaEtc/KristinaEtc.github.io/master/schemes/5logic.png)
<em>Рис. 4: Граф работы программы<em>

В бесконечном цикле постоянно опрашиваются значения датчиков, и в зависимости от того, какие значения мы получаем, граф переходит в то или иное состояние. Изначально (опрделеляется константой) сигнализация активна. Пользователю дается некоторое время (задается константой – у меня это 30 секунд) на «собраться и уйти». После устанавливаем флаг, что сигнализация работает. Из этого состояния мы можем или отключить ее, или активировать, затронув датчики (вор!) срабатывает бипер и для его отключения надо ввести пароль (123456 – устанавливается прошивкой). Если вводится верный пароль – сигнализация отключается, неверный – продолжает громко сообщать о вторжении. 

Вот, собственно, и все:

{% highlight js %}
switch(gFSMState){
    case FSMSTATE_RESET: 
      passed = gCurrentMillis-gTimeoutStart;
      if(passed>START_TIMEOUT){
        Serial.println("Starting");  
        gFSMState = FSMSTATE_ACTIVE;
        showState = true;
      }else{
        showState = timer;
      }
      break;
    case FSMSTATE_ACTIVE: //protection on
      sensors = readSensors(timer);
      if(sensors!=0){
        gSensors = sensors;
        gTimeoutStart = gCurrentMillis;
        gFSMState = FSMSTATE_DETECT;        
        showState = true;
      }
      break;
    case FSMSTATE_DETECT:     
      sensors = readSensors(timer); 
      passed = gCurrentMillis-gTimeoutStart;
      if(passed>DEACTIVATE_TIMEOUT){
        activateAlert();
        gFSMState = FSMSTATE_ALERT;
        showState = true;
      }else{        
        showState |= timer;
      }
      break;
    case FSMSTATE_ALERT:       
      sensors = readSensors(timer);   
      showState |= timer;
      break;
    case FSMSTATE_INACTIVE:            
      break;
    case FSMSTATE_WAIT:
      passed = gCurrentMillis-gTimeoutStart;
      if(passed>ACTIVATE_TIMEOUT){
        Serial.println("activateAlarm");  
        gFSMState = FSMSTATE_ACTIVE;
        showState = true;
      }else{
        showState |= timer;
      }
      break;     
    default:
      gFSMState = FSMSTATE_ACTIVE;
      showState = true;
      break;     
  }
  if(showState){
    dumpStateSerial();
    displayState(buttonsWereVisible, sensors);  
  }
  
  gCounter++; 
}
{% endhighlight %}

 А теперь бегом за [кодом](https://github.com/KristinaEtc/KristinaEtc.github.io/blob/master/arduino_sign/dumptouch/dumptouch.ino) и паяльником! 

 [Посмотреть](https://drive.google.com/file/d/0B6hv1ob9LkISVnZwdm9DR2lwN0U/view) как работает готовое устройство:

 1. Включаем сигнализацию. Чтобы можно было спокойно покинуть помещения, не затронув датчики, запускается счетчик на 30 секунд.
 2. Проверяем работу тачскрина
 3. Подаем сигналы на датчики, когда сигнализация выключена: реакции нет
 4. Включаем сигнализацию, предварительно отсоединив магнит от герконового датчика, а потом его вернув на место (все равно срабатывает)
 5. Выключаем сигнализацию по коду. 
 
 Все работает как надо. Теперь мы надежно защищены. ( ͡° ͜ʖ ͡°)

 

