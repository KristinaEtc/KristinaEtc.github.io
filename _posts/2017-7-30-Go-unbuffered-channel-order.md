---
layout: post
title: Cинхронность отправки и получения данных по небуферизированным каналам в Go
---

Листала <a href="https://www.amazon.co.uk/d/Books/Go-Action-William-Kennedy/1617291781">книгу</a>, в которой пригляделся пример с небуферизированными каналами:

![alt text](http://i.imgur.com/SxRhl1C.png)
![alt text](http://i.imgur.com/6wIiUoY.png)

Эмулируется игра в теннис с двумя игроками. Игрок представлен горутиной, которая читывают и записывают в канал значение (перекидывание мячика).
Вывод был следующий: 

![alt text](http://i.imgur.com/ETLkUzP.png)

Резонно возникает вопрос: можно ли быть уверенным в том, что значение, которая передала первая горутина (строка 32), прочитает вторая горутина (строка 45), а не та же, что и отправила? Иными сломами, 
может ли возникнуть ситуация, при которой вывод программы будет следующий:

```
Player Nahal Hit 1
Player Djokovic 2 
Player Nahal Hit 3
Player Nahal Hit 4 // здесь горутина, готорая отправила "мячик", его же и получила
Player Djokovic 5
```

Вооруживщись отсылкой к авторитетам с предположением, что автор книги более компитентен, я начала размышлять, по какой причине так уверенно было реализовано чтение и запись в одной функции без боязни незапланированного чтения значения одной и той же горутиной.
Первой мыслью было детерминированная последовательная передача ресурсов из канала планировщиком горутинам в последовательности, как они "были зарегестрированы" на получение данных. То есть если 
вторая горутина первая встала в очерeдь на чтение, то при записи однозначно ей будет переданы данные на чтение. Эта версия, однако, весьма сомнительная, потому что в небуферизированных каналах чтение и запись из канала планировщик осуществляет в случайном порядке 
(для примера достаточен любой код с несколькими горутинами и capacity канала больше, чем 1, хоть <a href="https://play.golang.org/p/ujZJuGaRri">этот</a>).

Ответ гораздо красивее: запись в небуферизированый канал выполняется синхронно с чтением. Даже так: CSP Go работает таким образом, что чтение в канал (но только небуферизированный) выполняется раньше, чем заканчивается запись. Для нас это значит, что в тот момент, когда первая горутина отправила в значение (строка 32), она заблокировалась. Так что  мячик в любом случае принимает вторая горутина (второй игрок) и все работает как и предполагалось.

Отличная иллюстрация поведения канала (а именно: его блокировки до момента чтения) из [3]:

![alt text](https://www.goinggo.net/images/goinggo/Screen+Shot+2014-02-16+at+10.10.54+AM.png)

Подробнее:
1. Самое простое - внимательно читать книги, а не рывками хватать информацию, в <a href="https://www.amazon.co.uk/d/Books/Go-Action-William-Kennedy/1617291781">Go action</a> это также упомянуто.
2. <a href="https://golang.org/ref/mem#tmp_7">Официальная документация</a>
3. <a href="https://www.goinggo.net/2014/02/the-nature-of-channels-in-go.html">The Nature Of Channels In Go</a>
4. <a href="https://groups.google.com/forum/#!topic/golang-nuts/PWt4r9b40bc">Are waiting sends to an unbuffer channel ordered - Google groups</a>
